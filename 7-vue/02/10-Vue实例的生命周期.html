<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Document</title>
</head>

<body>
  <div id="app">
    <div>{{msg}}</div>
    <button @click='update'>更新</button>
    <button @click='destroy'>销毁</button>
  </div>
  <script type="text/javascript" src="../vue.js"></script>
  <script type="text/javascript">
    /*
      Vue实例的生命周期.  从创建 到销毁的过程 ，这些过程中会伴随着一些函数的自调用。我们称这些函数为钩子函数
      
    */

    var vm = new Vue({
      el: '#app',
      data: {
        msg: '生命周期'
      },
      methods: {
        update: function () {
          this.msg = 'hello';
        },
        destroy: function () {
          this.$destroy();
        }
      },
      beforeCreate: function () {
        //beforeCreate| 在实例初始化之后，数据观测和事件配置之前被调用 此时data 和 methods 以及页面的DOM结构都没有初始化  什么都做不了
        console.log('beforeCreate');
      },
      created: function () {
        // created | 在实例创建完成后被立即调用此时data 和 methods已经可以使用  但是页面还没有渲染出来
        console.log('created');
      },
      beforeMount: function () {
        //beforeMount | 在挂载开始之前被调用   此时页面上还看不到真实数据 只是一个模板页面而已
        console.log('beforeMount');
      },
      mounted: function () {
        //mounted | el被新创建的vm.$el替换，并挂载到实例上去之后调用该钩子。  数据已经真实渲染到页面上  在这个钩子函数里面我们可以使用一些第三方的插件.以及请求数据
        console.log('mounted');
      },
      beforeUpdate: function () {
        //beforeUpdate | 数据更新时调用，发生在虚拟DOM打补丁之前。   页面上数据还是旧的
        console.log('beforeUpdate');
      },
      updated: function () {
        //updated | 由于数据更改导致的虚拟DOM重新渲染和打补丁，在这之后会调用该钩子。 页面上数据已经替换成最新的
        console.log('updated');
      },
      beforeDestroy: function () {
        //beforeDestroy | 实例销毁之前调用
        console.log('beforeDestroy');
      },
      destroyed: function () {
        //destroyed | 实例销毁后调用
        console.log('destroyed');
      }
    });
  </script>
</body>

</html>